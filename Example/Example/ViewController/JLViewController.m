//
//  JLViewController.m
//  Example
//
//  Created by Joshua Lareta on 8/2/14.
//  Copyright (c) 2014 Joshua Lareta. All rights reserved.
//

#import "JLViewController.h"
#import "Object1.h"
#define  numberOfRecordsString @"Current Number Of Records:"

@interface JLViewController (){
    NSOperationQueue *queue; // Handles the background thread

}

@end

@implementation JLViewController

- (id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil
{
    self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil];
    if (self) {
        // Custom initialization
    }
    return self;
}

-(void)loadView{
    UIView *view = [[UIView alloc]initWithFrame:[UIScreen mainScreen].bounds];
   
    UILabel *numberOfRecords = [[UILabel alloc]initWithFrame:CGRectMake(0, 100, 320, 50)];
    numberOfRecords.tag = 2;
    numberOfRecords.text = [NSString stringWithFormat:@"%@ 0",numberOfRecordsString];
    [view addSubview:numberOfRecords];
    
    UIButton *addButton = [UIButton buttonWithType:UIButtonTypeRoundedRect];
    addButton.frame = CGRectMake(0, 50, 150, 50);
    [addButton setTitle:@"Add (1000) Records" forState:UIControlStateNormal];
    addButton.tag = 1;
    [addButton addTarget:self action:@selector(addRecord:) forControlEvents:UIControlEventTouchUpInside];
    [view addSubview:addButton];

    
    UIButton *deleteButton = [UIButton buttonWithType:UIButtonTypeRoundedRect];
    deleteButton.frame = CGRectMake(150, 50, 160, 50);
    [deleteButton setTitle:@"Delete (1000) Records" forState:UIControlStateNormal];
    deleteButton.tag = 3;
    [deleteButton addTarget:self action:@selector(deleteRecords:) forControlEvents:UIControlEventTouchUpInside];
    [view addSubview:deleteButton];
    
    UITextField *tfField = [[UITextField alloc]initWithFrame:CGRectMake(0, 200, 320, 40)]; //Just to test if process will block main thread
    tfField.placeholder = @"Type here";
    [view addSubview:tfField];
    
    self.view = view;
}
- (void)viewDidLoad
{
    [super viewDidLoad];
    queue = [NSOperationQueue new];

	// Do any additional setup after loading the view.
}

- (void)didReceiveMemoryWarning
{
    [super didReceiveMemoryWarning];
    // Dispose of any resources that can be recreated.
}

#pragma mark - record actions
-(void) addDBRecord:(JLRecords *)record{
/*
 
 * Use the passed JLRecords instance to query for the table
 * Use the same context per thread, in this case use getTableSameContext method to create an object
 * Since the save record is at the end of the loop if we use different context each time the only thing that will be saved is the last value generated by the loop in this case newObject.property1 = 1000
*/
    for(int i = 0;i<10000;i++){

        Object1 *newObject = (Object1 *)[[record getTableSameContext:@"Object1"]create];
        newObject.property1 = [NSString stringWithFormat:@"%d",i+1];
        


    }
    [record save]; // included in the loop just to see that it is not crashing and it is better to put it outside the loop

    
  }

-(void)deleteDBRecord:(JLRecords *)record{
/*
 
 * Use the passed JLRecords instance to query the table
 * Use the getTable method to fetch a new context to separate it from the other process like adding multple entries which is accessing a context from a different thread
 
*/
    
   NSMutableArray *result = [[[[record getTable:@"Object1"]offset:0]limit:10000]find];
    for(int i = 0;i<10000;i++){
        if([result count]>i){
            Object1 *object = (Object1 *)result[i];
            [record deleteObject:object];
            
        }
  
    }
    [record save];
    

    
}
#pragma mark - Button Actions

-(void)addRecord:(id)sender{
    
    NSLog(@">>> Adding records now");
    
    
/*
 
 * If a JLRecords should be put into a queue it is advisable to create an instance of JLRecord per operation to handle the context per thread.
 
 * Just pass the instance of JLRecords to the operation
 
*/
    JLRecords *record = [JLRecords new];
    record.delegate = self;

    NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self
                                                                           selector:@selector(addDBRecord:) object:record];
    
    [queue addOperation:operation];
}


-(void)deleteRecords:(id)sender{
    
/*
 
 * If a JLRecords should be put into a queue it is advisable to create an instance of JLRecord per operation to handle the context per thread.
 * Just pass the instance of JLRecords to the operation

*/

    JLRecords *record = [JLRecords new];
    record.delegate = self;

    
    NSLog(@">>> Deleting records now");
    NSInvocationOperation *operation = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(deleteDBRecord:) object:record];
    [queue addOperation:operation];
}

#pragma mark JLRecords delegate
-(void)JLDatabaseUpdateComplete{
    NSLog(@">>> Records updated");
    
    //This is being done in the main thread
    
    JLRecords *records = [JLRecords new];
    NSMutableArray *result = [[records getTable:@"Object1"]find];
    UILabel *numberOfRecords = (UILabel *)[self.view viewWithTag:2];
    numberOfRecords.text = [NSString stringWithFormat:@"%@ %d",numberOfRecordsString,[result count]];
}
@end
